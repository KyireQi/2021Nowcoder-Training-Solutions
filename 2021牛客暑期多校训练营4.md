# 2021牛客暑期多校训练营4

## 题解：



> $F. \space Just \space a \space joke$

### 思路：

1. 看到标题和题面，大致判定是属于博弈论的签到题。~~所以不要瞎想到图论判环，bfs这些过于高级的操作~~
2. 设总边数为$e$​，总点数为$p$​。~~易知~~第一次操作会使$e-1$​，而第二次操作若是使得点数减少$k$​​，那么边数便会减少$k-1$，即$p-k, \space e-(k-1)$​​​。
3. 将边数和点数综合进行考虑，发现每次操作都会使得边数和点数之和**减少一个奇数**。所以在Alice的操作轮次，边数点数之和会减少一个奇数，而在Bob的操作回合则会减少一个偶数。
4. 最终答案只需要判断一下边数点数之和的奇偶性即可。

### 代码：

```c++
#include <bits/stdc++.h>
using namespace std;
 
int main() {
    int n,m;
    scanf("%d%d", &n, &m);
    for(int i = 0; i < m; i++) {
        int a, b;
        scanf("%d%d", &a, &b);
    }
    
    if((m + n) % 2 == 0) {
        printf("Bob");
    }
    else {
        printf("Alice");
    }
    
    return 0;
}
```

---




> $I. \space Inverse Pair$

### 思路：

1. 题目大意是说，一个全排列的$weight$是它的逆序对数目。任选一些数字加一，使得$weight$最小化。
2. 首先第一个知识点是求逆序对数目。这个可以用归并排序或者树状数组来解决。
3. 其次是要想到，某个数加一，对于**它以及它之后形成的逆序对数目没有影响**。所以加一的策略是要看这个数左边的子序列中，有没有一个数仅仅比它大$1$​，有的话就可以给这个数加一，逆序对总数目减一。
4. 那么答案就是遍历完整个数组之后的逆序对总数。

### 代码：

```c++
#include <bits/stdc++.h>
using namespace std;
const int maxn = 2e5 + 10;
 
int a[maxn];//a[maxn]，b[maxn]为归并排序要用的两个数组
int b[maxn];
int num[maxn];//存储原始排列
int pos[maxn];//存储每个数在全排列中的位置
long long ans = 0;//逆序对数目

void merge(int l, int r) {//归并排序求逆序对的板子
    if(l >= r) {
        return ;
    }
    int mid = (l + r) >> 1;
    int p = l, q = mid + 1;
    int pos = l;
    merge(l, mid);
    merge(mid + 1, r);
    while(p <= mid || q <= r) {
        if(q > r || (p <= mid && a[p] < a[q])) {
            b[pos++] = a[p++];
        }
        else {
            b[pos++] = a[q++];
            ans += mid - p + 1;
        }
    }
    for(int i = l; i <= r; i++) {
        a[i] = b[i];
    }
}
 
int main()
{
    int n;
    scanf("%d",&n);

    for(int i = 0; i < n; i++) {
        int tmp;
        scanf("%d", &tmp);
        a[i] = tmp;
        num[i] = tmp;
        pos[num[i]] = i;
    }

    merge(0, n - 1);

    for(int i = 1; i < n; i++) {
        int now = num[i];
        if(now != n) {//如果是最大值，就直接跳过
            //如果比now大1的数存在，且没有被+1，而且在now的左边
            if(pos[num[i] + 1] != -1 && pos[num[i] + 1] < i) {
                pos[num[i]] = -1;//加一之后要做个标记
                ans--;//逆序对数目减一
            }
        }
    }

    printf("%lld", ans);
    
    return 0;
}
```

---



> $J. \space Average$

## 思路：

1. 表面上看是求子矩阵的最大平均值，但是从题目给的输入数据来看。很有可能可以简化运算。

2. 稍稍推导一下，以矩阵左上角为坐标原点，水平向下为$x$轴，水平向右为$y$轴。

   设子矩阵左上坐标为$(a_1, b_1)$​，右下坐标为$(a_2, b_2)$​​​。该子矩阵平均值为：
   $$
   \frac{(b_2 \space - \space b_1) \times \sum_{i = a_1}^{a_2}a[i] + (a_2 \space - \space a_1) \times \sum_{i = b_1}^{b_2}b[i]}{(a_2 \space - \space a_1) \times (b_2 \space - \space b_1)} = \frac{\sum_{i = a_1}^{a_2}a[i]}{a_2 \space - \space a_1} \space + \space \frac{\sum_{i = b_1}^{b_2}b[i]}{b_2 \space - \space b_1}
   $$

3. 对于给出的两个数组，分别求各自限定最小长度子区间的最大平均值。答案就是两个最大平均值之和。

4. 求限定最小长度子区间的最大平均值，可以参考另外一题：

   > [102. 最佳牛围栏 - AcWing题库](https://www.acwing.com/problem/content/description/104/)

5. 易知平均值的取值范围为$0 \sim 10^{5}$，那么我们可以用二分的思想来查找$ans$。​​

6. 把数列中的每个数都减去二分的值$ans$​,就转化成判定“是否存在一个长度不小于 L 的子段 ,子段和非负”。若是存在，就说明$ans$小了。否则$ans$​就大了。

7. 子段和可以用一个前缀和去维护。

## 代码：

```c++
#include<cstdio>
#include<cstring>
#include<iostream>
using namespace std;

const double eps = 1e-9;//设定精度，其实1e-6就能AC
const int maxn = 1e5 + 10;
int n, m;
double num[maxn];//可以少开一个数组，节省空间。记得是double类型
double sum[maxn];//前缀和维护

double solve(int n, int len) {
    memset(num, 0, sizeof(num));//记得清零，因为要输入两次
    for(int i = 1; i <= n; i++) {
        scanf("%lf", &num[i]);
    }

    double l = 0, r = maxn;//设置平均值范围
    while(r - l >= eps) {//记住是枚举实数，而不是整数
        double mid = (l + r) / 2;

        for(int i = 1; i <= n; i++) {
            sum[i] = sum[i - 1] + num[i] - mid;//每次都要更新前缀和
        }

        double minn = maxn;
        double ans = -maxn;
        for(int i = len; i <= n; i++) {//找出最大的子段和
            minn = min(minn, sum[i - len]);
            ans = max(ans, sum[i] - minn);
        }
        
        //更新边界
        if(ans >= 0) {
            l = mid;
        }
        else {
            r = mid;
        }
    }

    return r;//返回l也能AC，但是据说这样会出事……
}

int main() {
    int x, y;
    scanf("%d%d%d%d", &n, &m, &x, &y);

    double ans1 = solve(n, x);
    double ans2 = solve(m, y);

    printf("%.9lf", ans1 + ans2);

    return 0;
}
```



---

> $C. \space LCS$

## 思路：

1. ~~一道简单的构造题。~~首先，要找出$a, b, c$​​三个数中的最小值$min$。填充$min$个字母$a$。这是三个字符串都需要的共同部分。
2. 然后开始用$b$和$c$​对剩下两对字符串分别进行填充。剩下的部分用$d,e,f$填充即可。
3. 如果发现无法填充，就说明不可构造。



## 代码：

```c++
#include<cstdio>
#include<iostream>
using namespace std;

int main() {
    int a, b, c, n;
    scanf("%d%d%d%d", &a, &b, &c, &n);

    int minn = min(a, min(b, c));
    a -= minn;
    b -= minn;
    c -= minn;
    
    if(minn + a + b + c > n) {//判断是否可以构造
        printf("NO");
        return 0;
    }

    string s1, s2, s3;
    for(int i = 0; i < minn; i++) {
        s1 += 'a';
        s2 += 'a';
        s3 += 'a';
    }
	
    //懒得去判断a,b,c谁是0了……
    for(int i = 0; i < a; i++) {
        s1 += 'b';
        s2 += 'b';
    }
    for(int i = 0; i < b; i++) {
        s2 += 'c';
        s3 += 'c';
    }
    for(int i = 0; i < c; i++) {
        s1 += 'd';
        s3 += 'd';
    }

    for(int i = s1.length(); i < n; i++) {
        s1 += 'e';
    }
    for(int i = s2.length(); i < n; i++) {
        s2 += 'f';
    }
    for(int i = s3.length(); i < n; i++) {
        s3 += 'g';
    }

    cout << s1 << endl;
    cout << s2 << endl;
    cout << s3 << endl;

    return 0;
}
```

---

## 总结：

1. 前两题还算正常。写第三题的时候，因为数组的类型设成int，导致某些地方可能精度丢失，WA了六次才过……浪费了很多时间，而且导致我们头昏脑涨，心态爆炸。
2. 导致写第四题的时候，状态不是很好。陷进某一种思路里出不去了，就一直卡住了。