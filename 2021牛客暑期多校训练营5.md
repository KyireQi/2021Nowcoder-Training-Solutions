# 2021牛客暑期多校训练营5

## 题解：

> $H. \space Holding \space Two$

### 思路：

1. 题意很简单，构造一个$m \times n$的$01$​矩阵，要求横排，竖排，对角线不能存在连续三个0或1
2. 每两列用一个01交替数列填充即可。

---

> $K.\space King \space of \space Range$

### 思路：

1. 每次固定左端点$l$，遍历右端点$r_i$​​。当区间最大最小值之差大于$k$时，这就是以$l$为左端点的**最小合法右端点**，那么之后所有的右端点都是合法的。答案只需要加上$(n - r_i + 1)$​​即可。
2. 那么要维护一段区间的最大最小值，可以利用单调队列来实现。维护最大值则利用单调递减队列，最小值利用单调递增队列。

### 代码：

```c++
#include<cstdio>
#include<iostream>
using namespace std;

const int maxn = 1e5 + 10;
int a[maxn];
int mx[maxn], mi[maxn];//mx[maxn]维护最大值，mi[maxn]维护最小只。存储数组a[maxn]区间最值的下标

int main() {
    int n, m;
    scanf("%d%d", &n, &m);
    for(int i = 1; i <= n; i++) {
        scanf("%d", &a[i]);
    }

    while(m--) {
        int k;
        scanf("%d", &k);

        int l = 1;//固定左端点
        int head_mx = 1, head_mi = 1;//mx,mi队列的队首
        int tail_mx = 0, tail_mi = 0;//mx,mi队列的队尾

        long long ans = 0;
        for(int r = 1; r <= n; r++) {//枚举右端点
            while (head_mx <= tail_mx && a[mx[tail_mx]] <= a[r]) {//寻找a[i]应该在的位置
                tail_mx--;//比a[i]小的元素都要出队
            }
            mx[++tail_mx] = r;//存储a[i]下标
            while (head_mi <= tail_mi && a[mi[tail_mi]] >= a[r]) {
                tail_mi--;//比a[i]大的元素都要出队
            }
            mi[++tail_mi] = r;

            while(a[mx[head_mx]] - a[mi[head_mi]] > k) {//如果遇到第一个合法区间
                ans += (long long)(n - r + 1);//后面的区间都是对答案有贡献的，直接累加
                l++;//不断移动左端点，直到区间不合法，再去寻找下一个合法右端点

                if(l > mx[head_mx]) {//如果队首元素不在区间范围内
                    head_mx++;//将其出队
                }
                if(l > mi[head_mi]) {
                    head_mi++;
                }
            } 
        }

        printf("%lld\n", ans);
    }

    return 0;
}
```

---

> $B. \space Boxs$

### 思路：

1. 首先需要想到的第一个关键点是**奸商的利用**。如果询问的话，只需要在最开始问一次就够了。这样每次开箱子后，就能知道剩下的箱子中黑球的数量。（开出白球就不变，开出黑球就减一）

2. 然后就是**开箱子的顺序**。因为球的颜色是随机的，所以期望最小值一定是从花费最少的箱子开始开。

3. 之后是**什么时候停止开箱**。当我们开到剩下的箱子都是同色时，就可以停下了。（黑球数量为0，或者黑球数目等于未开箱子数）

   而当打开第`i`个箱子时，剩下`n - i`个箱子同色的概率为：
   $$
   \frac{2^i}{2^n} = \frac{1}{2^{n - i}}
   $$
   所以打开第`i`个箱子的期望值为：
   $$
   \sum_{j = 1}^{i}w[j] × \frac{1}{2^{n - i}}
   $$
   最后累加起来就行。

4. 同时要注意到，询问了奸商后，哪怕运气最差，**最后一个箱子也是不用开的**。所以遍历的时候要注意范围。

5. 也存在不用询问的可能性，这样就要把所有的箱子打开。所以最终答案为**打开所有箱子的耗费总和**和**询问奸商的期望最小值**中，两者的**最小值**。



### 代码：

```c++
#include<cstdio>
#include<cmath>
#include<algorithm>
#include<iostream>
using namespace std;

const int maxn = 1e5;
double w[maxn];

int main() {
    int n;
    double c;
    scanf("%d%lf", &n, &c);
    for(int i = 1; i <= n; i++) {
        scanf("%lf", &w[i]);
    }
    sort(w + 1, w + 1 + n);//一定是从最便宜的箱子开始打开

    double ans = 0, sum = 0;
    for(int i = 1; i < n; i++) {//注意下标的范围，默认询问奸商，所以最后一个箱子一定不开
        sum += w[i];//计算打开所有箱子的价格
        ans = (ans + sum) / 2;
    }

    printf("%.9lf", min(sum + w[n], ans + c));//不询问奸商需要打开最后一个箱子，询问的话要加上询问费

    return 0;
}
```

---

## 总结：

1. 签到题手速慢了。
2. 单调队列和数学都不是我们熟悉的点，所以也没有写出来。