# 2021牛客暑期多校训练营7（题解部分）



## H题：xay loves count

### 题意：

给定一段序列{an},求满足$a_i*a_j=a_k$​的个数（i,j,k可相等），1<=n<=10^6.

### 思路：

最简单的就是写三重循环，但肯定超时。根据数据就想到了要优化到，$nlogn$或者n根号n的复杂度。于是就先根据题目所提供的数值也都是1~1e6，所以可以先用桶排来标记一下每个数字出现的次数。最后再遍历一遍看是否满足条件。

但是，最坑人的是 ans 居然爆 Int ,淦！这个坑百掉不厌（不是

### 代码：

```c++
#include<iostream>//未优化
using namespace std;

int main()
{
    int n,p=0;
    cin>>n;
    int a[n];
    for(int i=0;i<n;i++)
    {
        cin>>a[i];
    }
    for(int i=0;i<n;i++)
    {
        for(int j=0;j<n;j++)
        {
            for(int k=0;k<n;k++)
            {
                if(a[i]*a[j]==a[k])
                p++;
            }
        }
    }
    cout<<p;
    return 0;
}
```

```c++
#include<iostream>//未优化
using namespace std;

int main()
{
    int n,p=0;
    cin>>n;
    int a[n];
    for(int i=0;i<n;i++)
    {
        cin>>a[i];
    }
    for(int i=0;i<n;i++)
    {
        for(int j=0;j<n;j++)
        {
            for(int k=0;k<n;k++)
            {
                if(a[i]*a[j]==a[k])
                p++;
            }
        }
    }
    cout<<p;
    return 0;
}
```

```c++
//优化后
#include<bits/stdc++.h>
#include<cstdio>
using namespace std;

const int maxn=1e6+5;
int a[maxn];
int num[maxn]={0};

int main() {
    int n;
    cin>>n;
    for(int i=0; i<n; i++) {
        cin>>a[i];
        num[a[i]]++;
    }
    sort(a,a+n);
    long long cnt = 0;
    for(int i=0; i<n; i++) {
        for(int j=1; j<(int)sqrt(a[i])+1; j++) {    
            if(a[i]%j==0){
                //cout<<cnt<<"***"<<endl;
                cnt+=num[a[i]/j]*num[j];
                //cout<<a[i]<<" "<<j<<" "<<cnt<<endl;  
                if(a[i]!=j*j){
                    //cout<<a[i]<<" "<<j<<" "<<cnt<<endl;  
                    cnt+=num[a[i]/j]*num[j];
                }              
            }          
        }
    }
    cout<<cnt<<endl;
}
```







## H题：xay loves or.

### 题意：

He gives you x and s, you need to calculate how many positive integer y satisfy    x or⁡ y= s

### 思路：

1|1=1,1|0=1,0|1=1，0|0=0.  样例输入2 5

010        对于确定的x,s我们逐位与，通过上面的四种情况可推理出 
101        x,s对应位都是1则y对应位有两种选择，x位上是0则y只有唯一选择，若x为1，s为0是无法实现的。

最后比赛的时候WA了9次，是因为注意题上y是正数，不为零.......................（大无语。。。

### 代码：

```c++
#include<iostream>
using namespace std;
int main() {
    long long x,s;
    //bool X[34],S[34];
    cin>>x>>s;
    long long ans=0;
    int flag=0;
    if(((x&1ll)==1)&&((s&1ll)==1)) {
        ans=2;
    } else if(((x&1ll)==0)&&((s&1ll)==1)) {
        flag=1;
        ans=1;
    } else if(((x&1ll)==0)&&((s&1ll)==0)) {
        ans=1;
    } else if(((x&1ll)==1)&&((s&1ll)==0)) {
        cout<<"0"<<endl;
        return 0;
    }
    x>>=1;
    s>>=1;
    while(x||s) {
        if(((x&1ll)==1)&&((s&1ll)==1)) {
            ans<<=1;
        }
        else if(((x&1ll)==0)&&((s&1ll)==1)){
            flag=1;
        }
        else if(((x&1ll)==1)&&((s&1ll)==0)) {
            ans=0;
            cout<<"0"<<endl;
            return 0;
        }
        //cout<<(x&1ll)<<" "<<(s&1ll)<<endl;
        //cout<<ans<<endl;
        x>>=1;
        s>>=1;
    }
    if(flag==0){
        ans--;
    }
    cout<<ans<<endl;
    return 0;
}
```





## 总结：

这一场俩签到题，两人分别开一道，思路都是正确地，可是坑掉少了，计数爆Int，和题上的数值范围的一些坑没有意识到，所以一直卡着，WA了很多次导致排名直冲倒数不是很好。下次需要有debug快速找坑的能力，排名就能upup！