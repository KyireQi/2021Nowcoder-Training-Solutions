 # 2021牛客暑期多校训练营4（题解部分）

 ## C题：LCS（补）
 ### 题意：
构造三个字符串s1、s2、s3，并且三个长度相同且为n，给定a,b,c表示(s1与s2的公共子串的最大长度为a,s2与s3的公共子串的最大长度为b,s3与s1的公共子串的最大长度为c)
 ### 思路：
这就是一道构造题，先找出a,b,c中最小的数（假设k=min(a,b,c)），这就是三个字符串的公共子串，并且用k个'a'填满，将那两个子串填上max个‘a’。之后再填两个串之间的公共子串，再依次用'b','c','d'填剩下的公共子串（虽然有两个串已经没了公共子串，但是懒得写if），若填出来的字符串长度大于则不能构造，若还有剩余的长度则用'x','y','z'三个不同的字母填满三个串

### 代码：
```
#include<cstdio>
#include<cstring>
#include<iostream>
#include<cmath>
using namespace std;
 
int main(){
    int a,b,c,n;
    cin>>a>>b>>c>>n;
    int k=min(a,min(b,c));//找三个串的公共子串长度
    string str1,str2,str3;
    a-=k;b-=k;c-=k;//标记未填的空间长度
    for(int i=0;i<k;i++){
        str1+='a';
        str2+='a';
        str3+='a';
    }
    //填两个串之间的公共子串
    for(int i=a;i>0;i--){
        str1+='b';
        str2+='b';
    }
    for(int i=b;i>0;i--){
        str2+='c';
        str3+='c';
    }
    for(int i=c;i>0;i--){
        str1+='d';
        str3+='d';
    }
    int q=str1.size(),w=str2.size() ,e=str3.size() ;
    //长度超了，就无法构造
    if(q>n||w>n||e>n) cout<<"NO";
    //剩下的填满
    else{
        cout<<str1;for(int i=q;i<n;i++)cout<<"x";cout<<endl;
        cout<<str2;for(int i=w;i<n;i++)cout<<"y";cout<<endl;
        cout<<str3;for(int i=e;i<n;i++)cout<<"z";cout<<endl;
    }
}
```

 ## F题：Just a joke
 ### 题意：
Alice（先手）和Bob玩游戏，游戏规则：有一个有n个节点的无向图。给定m条边的输入（其实没用，，，，，

The player who can't operate will lose the game.Each turn, the player should do one of the following operations.
1. Select an edge of G and delete it from G.（删一条边）
2. Select a connected component of G which doesn't have any loop, then delete it from G.（若无联通分量即无环，删整个联通的）
 ### 思路：
就是一道博弈题，本来找规律就可以找出来的，结果开始纠结贼久.........（直接放代码）
### 代码：
```
#include<stdio.h>
#include<math.h>
int main(){
    int m,n;
    scanf("%d%d",&n,&m);
    int a;int b;
    for(int i=0;i<m;i++){
        scanf("%d%d",&a,&b);
    }
    if(abs(m-n)%2==1){
        printf("Alice\n");
    }
    else
        printf("Bob\n");
     
}
```

 ## I题：Inverse Pair
 ### 题意：
定义一个序列的权重是它所含逆序对的数量。给出一个序列a，对其中的每一个数可以选择加一或者不改变，由此得到一个新的序列c，求c的最低权重。
###思路：
对于序列中的每一个数，考虑该数加一对整体逆序对带来的改变。设该数为a，若a+1所在下标比a 的更小，且原来a-1的数没有加一成为a，此时将a加一，能够使整体逆序对减少，故将此处的a+1。
 ### 代码：
 ```
#include<cstdio>
const int maxn=200050;
long long MergeSort(int s[], int left, int middle, int right)
{
   int i = left, j = middle;
   int b[right - left + 1];
   int index = 0;
   long long sum = 0;
   long long t = 0;
   //----------------------------------------------
   //核心代码
   while (i < middle && j <= right)
   {
       if (s[i] > s[j])
       {
           b[index++] = s[j++];
           t++;
       }
       if (s[i] <= s[j] || j == right + 1)
       {
           sum += t * (middle - i);
           b[index++] = s[i++];
           t = 0;
       }
   }
   //----------------------------------------------------------------
   while (i < middle)
       b[index++] = s[i++];
   while (j <= right)
       b[index++] = s[j++];
 
   index = 0;
   for (int m = left; m <= right; m++)
       s[m] = b[index++];
   return sum ;//最后返回给k值
}
long long k = 0;
void Merge(int s[], int low, int high)
{
   if (low < high)
   {
       int mid = (low + high) / 2;
       Merge(s, low, mid);
       Merge(s, mid + 1, high);
       k += MergeSort(s, low, mid + 1, high);
   }
}
int main(){
    int n;
    scanf("%d",&n);
    int a[maxn],b[maxn];//b数组记录a中数组数字的位置
    b[0]=0;a[0]=0;
    for(int i=1;i<=n;i++){
        scanf("%d",&a[i]);
        b[a[i]]=i;
    }
    for(int i=1;i<n;i++){//
        if(b[i+1]<b[i]&&a[b[i-1]]<i){
            a[b[i]]++;
        }
    }
     
    /*for(int i=1;i<=n;i++){
        printf("%d ",a[i]);
    }*/
    Merge(a, 1, n);//计算逆序对
    printf("%lld\n", k);
     
    return 0;
     
}
```

 ## J题：Average（补）
 ### 题意：
给两个数组a_{i}和b_{i},并以之构造一个矩阵满足,求至少x行y列子矩阵的最大平均值。
### 思路:
·问题转化为求长度至少为x的子序列最大平均值与长度至少为x的子序列最大平均值之和。
·由于题中的数据：,所以平均值为1~1e5之间，二分求最大值，通过前缀和、尺取处理优化。
 ### 代码：
 ```
#include<bits/stdc++.h>
using namespace std;
const int maxn=1e5+10;
int n,m,x,y;
int a[maxn];
double b[maxn];
double fun(int k,int d) {//求最大平均值
	double l=0.0,r=1e5;
	for(int i=1; i<=k; i++) cin>>a[i];
	while(r-l>1e-8) {
		double mid=(l+r)/2.0,sum,t=0.0;
		for(int i=1; i<=d; i++) b[i]=b[i-1]+a[i]-mid; //前缀和处理
		sum=b[d];//从最短的长度开始
		for(int i=d+1; i<=k; i++) {
			t=min(t,b[i-d]);//标记最小前缀和，尺取 
			b[i]=b[i-1]+a[i]-mid;//继续前缀和处理
			sum=max(sum,b[i]-t);
		}
		if(sum>0) l=mid;
		else r=mid;
	}
	return r;
}
int main() {
	cin>>n>>m>>x>>y;
	printf("%.10lf\n",fun(n,x)+fun(m,y));
	return 0;
}
```
 ## 总结：
这次比赛一共过了俩题，开了四题。

开局看通过数量，判断F是签到题，对于F题有个严重的失误，误判成较难的联通图的题，耽误了很长时间并转向I题，结果根据推理发现这是一道规律题完成签到。

对于I题看完题判断出了逆序对的题目，在咔嚓一顿分析后完成！对于逆序对不熟悉，所以分析较麻烦。

最可惜的是C题构造题，因为经验较少，思维混乱所以一直没捣腾出来东西，，，，，，

而J题则是T某执意要开的题，还给错判断成dp（该打，结果分析后是一道二分题目。

总的来说，需要提升一下做题的经验和对于题目的难度判断和分析，对于基础的二分、尺取、前缀和、逆序对等掌握有了进一步增强。