# 2021牛客暑期多校训练营8

## 题解：



> $E. \space Rise \space of \space Shadows$​

### 题意：

- 对于所给年份，是质数且是闰年的输出$yes$，否则输出$no$。

### 思路：

1. 众所周知，闰年年份不可能是质数。直接全部输出$no$即可

---

> $A. \space Ares, \space Toilet \space Ares$

### 题意：

- ~~根本看不懂~~

### 思路：

1. 直接根据样例解释来写公式输出就行
2. 但是要注意$0 \leq x$，意味着可能一行代码也得不到，那么就会100%失败，所以要跳过$x=0$​的情况
3. 除以一个数取模，就是乘它的逆元再取模

### 代码：

```c++
#include<cstdio>
#include<iostream>
using namespace std;

const int mod = 4933;

int qPow(int a, int b, int m) {//快速幂求逆元
    int ans = 1;
    while(b > 0) {
        if((b & 1) == 1) {
            ans = a * ans % m;
        }
        a = a * a % mod;
        b >>= 1;
    }
    return ans;
}

int main() {
    int n, m, k, a, l;
    scanf("%d%d%d%d%d", &n, &m, &k, &a, &l);
    a %= mod;//a可以先取模

    int ty = 1, tz = 1;
    while(k--) {
        int x, y, z;
        scanf("%d%d%d", &x, &y, &z);
        if(x != 0) {//特判x
            ty = ty * (z - y) % mod;
            tz = tz * z % mod;
        }
    }

    int ans = ty * qPow(tz, mod - 2, mod) % mod;
    ans = (ans + a) % mod;
    printf("%d", ans);

    return 0;
}
```

---

> $K. \space Yet \space Another \space Problem \space About \space Pi$

### 题意：

- 给定无限大，已知长宽的网格图。和长度为$\pi$的绳子，如何让绳子跨越最多格子数
- 输出所能到达的最多的格子数。

### 思路：

1. ~~其实模型很像完全背包~~，但是因为是浮点类型，很难转换。所以可以考虑用是带反悔的贪心去解决~~（大概吧）~~
2. 对于给出的$w,d$，它们的贡献都是$2$，所以要是沿着边摆放，一定沿着$w,d$​中的最小值去摆放。此时代价为$min\{w,d\}$。
3. 除此之外，还能斜着摆放。此时代价为$\sqrt{w^2+d^2}$，贡献为$3$​。
4. 我们根据两者的单位价值去贪心，即去比较$\frac{2}{min\{w,d\}}$和$\frac{3}{\sqrt{w^2+d^2}}$。哪种选择单位价值高，就全部选择该种方案。
5. 但是对于剩下来的边角料，或许凑一凑能够沿着边摆放。又或者可以沿着对角线摆放。所以我们还需要对比一下这几种待选策略的最大值，才是最终答案。

### 代码：

```c++
#include<cstdio>
#include<cmath>
#include<iostream>
using namespace std;

const double pi = acos(-1);

int main() {
    int t;
    scanf("%d", &t);
    
    while(t--) {
        double w, d;
        scanf("%lf%lf", &w, &d);
        double minn = min(w, d);//最小值
        double diag = sqrt(w * w + d * d);//斜边值

        int ans;
        if(diag < 1.5 * minn) {//对比价值，按照对角线摆放
            int cnt = pi / diag;//分割次数
            double rest = pi - diag * cnt;//边角料长度
            ans = 4 + 3 * cnt + 2 * (int)(rest / minn);//先假设全部按照对角线摆放
            if(cnt >= 1) {//如果条件允许
                //对比一下，腾出一个斜边长度沿最小边摆放的价值
                ans = max(ans, 4 + 3 * (cnt - 1) + 2 * (int)((rest + diag) / minn));
            }
        }
        else {//按照最小边摆放
            int cnt = pi / minn;
            double rest = pi - minn * cnt;
            ans = 4 + 2 * cnt + 3 * (int)(rest / diag);
            if(cnt >= 1) {
                ans = max(ans, 4 + 2 * (cnt - 1) + 3 * (int)((rest + minn) / diag));
            }
        }

        printf("%d\n", ans);
    }

    return 0;
}
```

---

> $D. \space OR$

### 题意：

- 给出$b_2 \sim b_n$和$c_2 \sim c_n$。需要构造$a_1 \sim a_n$，满足$b_i = a_{i-1}|a_i, \space c_i = a_{i - 1} + a_i$。

### 思路：

1. 发现一旦确定了$a_1$，那么其后的$a_i$也确定了。只需要检验是否合法即可。~~但这样必定TLE~~

2. ~~众所周知~~，有一个加法转化公式：
   $$
   a + b = (a \space \& \space b) + (a \space | \space b)
   $$

3. 那么稍加转化，就会得到：
   $$
   \begin{cases}
   c_i = a_{i - 1} + a_i = (a_{i - 1} \space \& \space a_i) + (a_{i - 1} \space | \space a_i)\\
   b_i = a_{i - 1} \space | \space a_i
   \end {cases}
   \space \Rightarrow \space a_{i - 1} \space \& \space a_i = c_i - b_i
   $$

4. 令$d_i = a_{i - 1} \space \& \space a_i$，发现和$b_i = a_{i - 1} \space | \space a_i$放在一起，~~有奇效~~，能够互不影响的确定二进制下$a_i$的每一位数。

5. 那么我们就枚举$a_1$的每一位，来据此检验其后的可行性

### 代码：

```c++
#include<cstdio>
#include<iostream>
using namespace std;

const int maxn = 1e5 + 10;
int b[maxn], c[maxn];

int main() {
    int n;
    scanf("%d", &n);
    for(int i = 2; i <= n; i++) {
        scanf("%d", &b[i]);
    }
    for(int i = 2; i <= n; i++) {
        scanf("%d", &c[i]);
        c[i] -= b[i];//c[i]数组已经没用了，可以直接接覆盖，节省空间
    }

    int ans = 1;
    for(int i = 0; i < 31; i++) {//枚举a[1]的每一位
        //pre0表示a[j]的前一位是否可以为0，初始化时的pre0表示a[1]的每一位，默认均可以
        int pre0 = 1, pre1 = 1;
        
        for(int j = 2; j <= n; j++) {//检查b[j]和c[j]是否合法
            int tmp_or = (b[j] >> i) & 1, tmp_and = (c[j] >> i) & 1;//将第i位取出
            int now0 = 0, now1 = 0;//检验当前位数是否可以为0或1
            if(tmp_and == 0 && tmp_or == 0) {//如果两者均为0
                now0 = pre0;//当前位置是否可以为0和前一位是否可以为0有关
            }
            else if(tmp_and == 1 && tmp_or == 1) {//如果两者均为1
                now1 = pre1;//当前位置是否可以为1和前一位是否可以为1有关
            }
            else if(tmp_and == 0 && tmp_or == 1) {//如果一个为0，一个为1
                now0 = pre1;//当前位置是否可以为0和前一位是否可以为1有关
                now1 = pre0;//当前位置是否可以为1和前一位是否可以为0有关
            }

            pre0 = now0;//位置前移
            pre1 = now1;

            if(pre0 == 0 && pre1 == 0) {//如果根本不可能构造
                printf("0");
                return 0;
            }
        }
        ans *= pre0 + pre1;//对答案有贡献
    }

    printf("%d", ans);

    return 0;
}
```

