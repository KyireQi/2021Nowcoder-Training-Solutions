# 2021牛客暑期多校训练营10（题解部分）

## H题：War of Inazuma (Easy Version)
### 题意：
给定n表示有n维立方体，可知其有 $2^{n}$ 个顶点，分别用0~$2^{n}-1$标记，且只有当二进制只有一位不同的数才能相邻。

顶点被'1'和'0'两方占领，相邻的友军不超过|$\sqrt{n}$|，请构造符合条件的情况。

### 思路：
![思路](https://img-blog.csdnimg.cn/a6cc3ff0e7ae443d98e5d5da732217db.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzUxODk1MDI2,size_16,color_FFFFFF,t_70#pic_center)
### 代码：
```
#include<iostream>
#include<string>
using namespace std;
int main(){
	string ans="10";
	string tem=ans;
	int n;
	cin>>n;
	for(int i=1;i<n;i++){
		for(int j=0;j<tem.size();j++){
			if(tem[j]=='0')tem[j]='1';
			else tem[j]='0';
		}
		ans=ans+tem;
		tem=ans;
	}
	cout<<ans<<endl;
}
```
## Train Wreck

### 题意：

以'()'的形式给出火车出栈入栈的顺序，'('代表入栈，')'代表出栈，给出n个数代表火车的颜色，任意排列这n个数，求是否存在一种情况使任意时刻入栈后栈中的颜色序列都是唯一的。

### 思路：

参考题解思路。将入栈出栈构成的颜色序列用树来表示，问题就转化成了求一种排列使树的任意点的子节点颜色都不相同。将所有节点染色，为了保证之后的颜色尽可能不重复，优先使用数量更多的颜色，如果在某一时刻，颜色数小于子节点数，即不能给所有节点染上不同颜色，则输出"NO"。

### 代码：

````c++
#include<bits/stdc++.h>
using namespace std;
const int N=2e6+5;
int n;
int tot,top,ans[N],c[N];
priority_queue<pair<int,int> >q;
vector<int>v[N];
void w(vector<int>a) {
	vector<pair<int,int> >tmp;
	for(int i=0; i<a.size(); i++) {
		if(q.empty()) {//如果颜色种数不足,无解
			puts("NO");
			exit(0);
		}
		int fi=q.top().first,se=q.top().second;
		q.pop();
		ans[a[i]]=se;
		tmp.push_back({fi-1,se});//每次染色后将这种颜色的数量-1
	}
	for(int i=0; i<tmp.size(); i++) {
		int fi=tmp[i].first,se=tmp[i].second;
		if(fi>0)q.push({fi,se});//若一种颜色已经用完，不存入队列
	}
}
int main() {
	scanf("%d",&n);
	string st;
	cin>>st;
	for(int i=1; i<=n; i++) {
		int x;
		scanf("%d",&x);
		c[x]++;
	}
	for(int i=1; i<=n; i++)
		if(c[i]) {
			q.push({c[i],i});
			c[i]=0;
		}//初始化优先队列
	tot=0;
	top=0;
	for(int i=0; i<=2*n-1; i++) {
		if(st[i]=='(') {
			v[top].push_back(++tot);//存入需要染色的节点
			top++;
			v[top].clear();
		} else
			w(v[top--]);
	}
	w(v[top]);
	puts("YES");
	for(int i=1; i<=n; i++)
		printf("%d ",ans[i]);
}

````

# 总结
这场比赛还算不错，就是用构造法，通过一二三维推测构造出了序列。但是对于STL数据结构的掌握不够，第二题没开出来。