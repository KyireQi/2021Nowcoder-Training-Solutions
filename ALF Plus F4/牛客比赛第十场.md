# 牛客第十场比赛

## 总结

这次比赛打的挺顺利，把会做的都给A了。F题一个伪正解竟然把题给过了。

## H题

### 题目大意

二进制下，仅有一位不同的两个数之间有连接，要求把$[0, 2^{n}-1]$的数分为两A，B组，要求与一个数$x$相连的数中，和这个数$x$同组的数不能超过$\lceil x^{1/2} \rceil$个。

输出一种结果即可。

## 思路

不难发现，二进制下，$1$的个数相差$1$的两个数之间才有可能有连接，所以我们把所有数，按照二进制下$1$的个数，分别分为A，B即可。

## 代码

```c++
#include <cstdio>
#include <iostream>
using namespace std;

int n;

int check(int x)
{
    int tmp = 0;
    while(x) {
        if(x & 1)
            tmp++;
        x >>= 1;
    }
    return tmp & 1;
}

int main()
{
    scanf("%d", &n);
    for(int i = 0; i < (1 << n); ++i) {
        if(check(i))
            printf("0");
        else
            printf("1");
    }
    return 0;
}
```

# F题

## 题意

给出一个出入栈顺序和一堆数字，构造一个序列满足任意时刻入栈时序列都是唯一的。

## 思路

入栈顺序会产生一个唯一的数组，我们要做的就是把这一堆数给分给题目给的数字，要求同一个数不能分到同一个栈顺序产生的数，那么我们可以贪心的想，优先把最多的给分了（两个数组都是）。

## 代码

```c++
#include <cstdio>
#include <iostream>
#include <vector>
#include <algorithm>
#include <queue>
using namespace std;

const int maxN = 1e6 + 7;

int n, ans[maxN];
char s[maxN << 1];

vector<int> pos[maxN];

struct Num {
    int times, num;
}stackNum[maxN], color[maxN];

struct cmpForNum {
    bool operator () (Num a, Num b) {
        return a.times < b.times;
    }
};

bool cmp(Num a, Num b)
{
    return a.times > b.times;
}

priority_queue<Num, vector<Num>, cmpForNum> q;

int main()
{
    scanf("%d", &n);
    scanf("%s", s + 1);
    int cnt = 0, posNum = 0;
    for(int i = 1; i <= (n << 1); ++i) {
        if(s[i] == '(') {
            ++cnt;
            stackNum[cnt].times++;
            stackNum[cnt].num = cnt;
            pos[cnt].push_back(++posNum);
        }
        else if(s[i] == ')')
            cnt--;
    }
    sort(stackNum + 1, stackNum + 1 + n, cmp);
    for(int i = 1; i <= n; ++i) {
        int x;
        scanf("%d", &x);
        color[x].num = x;
        color[x].times++;
    }
    for(int i = 1; i <= n; ++i)
        if(color[i].times != 0)
            q.push(color[i]);
    bool succ = true;
    for(int i = 1; i <= n; ++i) {
        if(stackNum[i].times == 0)
            break;
        vector<Num> tmp;
        for(int j = 0; j < pos[stackNum[i].num].size(); ++j) {
            if(q.empty()) {
                succ = false;
                break;
            }
            Num now = q.top(); q.pop();
            ans[pos[stackNum[i].num][j]] = now.num;
            now.times--;
            if(now.times != 0)
                tmp.push_back(now);
        }
        if(succ == false)
            break;
        for(int j = 0; j < tmp.size(); ++j)
            q.push(tmp[j]);
    }
    if(succ) {
        printf("YES\n");
        for(int i = 1; i <= n; ++i)
            printf("%d ", ans[i]);
        printf("\n");
    }
    else {
        printf("NO\n");
    }
    return 0;
}
```

