# 牛客第四场比赛

这次感觉打的很顺利，把会做的题目都打完了，唯一不足的就是套用算法模板的时候套错了。





## 题解

###  I题 题目大意

给定一个1~n的排列，你可以给其中任意个数加上1，使得到的新序列的逆序对个数尽量少。

### 思路

由于是一个排列，即**每个数仅会出现一次**。

我们考虑什么情况下把一个数X加上1之后，会让逆序对减少，那么肯定是这个数的左面存在比它大一的数，此时，把X加一之后，逆序对的数量就会减少1，因为**比它大1的数只有一个，在X加上1之后，就与X相等了，比它大2及以上的数，还是比X大，而比X小的数，还是比X小**。

**具体解法：** 我们统计一下存在多少个X，满足比它大1的数在它左面。当然这样的数对只能使用一次。比如 3 2 1，把1加上1之后，就和2相等了，所以此时再把2加1不会使结果增加。求出原本的逆序对，然后减去我们找出的满足条件的数对就可以了。


### 代码

```c++
#include <cstdio>
using namespace std;

const int maxN = 2e5 + 7;
int n, a[maxN], b[maxN], c[maxN], used[maxN];

int ask(int x)
{
    int ans = 0;
    for(; x; x -= x & -x)
        ans += c[x];
    return ans;
}

void add(int x, int y)
{
    for(; x <= n; x += x & -x)
        c[x] += y;
}

int main()
{
    scanf("%d", &n);
    for(int i = 1; i <= n; ++i) {
        scanf("%d", &a[i]);
        b[a[i]] = i;
    }
    long long revNum = 0;
    for(int i = n; i >= 1; --i) {
        revNum += ask(a[i] - 1);
        add(a[i], 1);
    }
    int minusNum = 0;
    for(int i = 1; i < n; ++i) {
        if(used[i])
            continue;
        if(b[i] > b[i + 1]) {
            used[i] = used[i + 1] = 1;
            minusNum++;
        }
    }
    printf("%lld\n", revNum- 1LL * minusNum);
    return 0;
}
```



### J题 题目大意

题目等价为：给定两个分别由n和m个数的序列a，b。分别找出长度不少于x和y的连续序列，使它们的平均值之和最大

### 思路

寻找长度不少于x且满足某些条件的题目，是属于那些**便于验证，暗示难以直接求出答案**的题，所以可以去二分。

对于每次二分出来的可能结果，我们把序列全体减去这个数，然后问题就成为了**是否存在一个长度不小于x，且其和大于0的连续序列**。

在验证过程中，我们可以先求出来新的数组的前缀和$sum$，假如我们想要寻找长度不小于L的，我们当前验证到了第$i$ 位($i >= L$)，那么当前能够取得的最大值，显然就是当前 $sum[i] - min\{sum[j]\}$ ，其中$1\le j\le i - L$ 。所以我们只用不断维护当前得$min\{sum[j]\}$，并且用当前得到的值取更新$ans$，即$ans=max\{sum[i] - min\{sum[j]\},ans\}$。最后判断$ans$是否不小于0。

```c++
#include <iostream>
#include <cstdio>
using namespace std;

const int maxN = 1e5 + 6;
int n, m, x, y;
double a[maxN], b[maxN], ans, tmp[maxN], sum[maxN];

bool judge(double num[], int n, int needLength, double x)
{
    double ans = -1e10, minVal = 1e10;
    for(int i = 1; i <= n; ++i) {
        tmp[i] = num[i] - x;
        sum[i] = sum[i - 1] + tmp[i];
    }
    for(int i = needLength; i <= n; ++i) {
        minVal = min(sum[i - needLength], minVal);
        ans = max(ans, sum[i] - minVal);
    }
    return ans >= 0;
}

int main()
{
    double l = 0, r = 0;
    scanf("%d%d%d%d", &n, &m, &x, &y);
    for(int i = 1; i <= n; ++i) {
        scanf("%lf", &a[i]);
        r = max(r, a[i]);
    }
    for(int i = 1; i <= m; ++i)
        scanf("%lf", &b[i]);
    while(r - l > 1e-6) {
        double mid = (l + r) / 2;
        if(judge(a, n, x, mid))
            l = mid;
        else
            r = mid;
    }
    ans += l;
    l = 0, r = 1e5;
    while(r - l > 1e-7) {
        double mid = (l + r) / 2;
        if(judge(b, m, y, mid))
            l = mid;
        else
            r = mid;
    }
    ans += l;
    printf("%lf", ans);
    return 0;
}
 
```

## E题

### 题目大意

给定一棵有n个节点的树，每个节点的权值$a[i]$未知，满足$l[i]\le a[i]\le r[i]$，其中$l[i],r[i]$为给定数值。每条边的权值为已知，其值为它连接的两个边的权值的异或值。求出满足条件的$a[i](1\le i\le n)）$的数量。($1\le n\le 10^5, 1\le l[i] \le r[i]\le 2^{30}$)
<!--more-->
[题目链接](https://ac.nowcoder.com/acm/contest/11255/E)

### 思路

由于每条边的值为给定值，所以只要确定了一个点的值，剩下的点的值也就被确定了，遍历整个树需要$O(n)$的时间，所以枚举$min\{r[i] - l[i]\}$的点，也会TLE。所以我们不能通过枚举可行值来计算答案。

1.  我们首先假设$a[1] = 0$，那么剩下所有的点都会被确定为$a[i]$

    那么假设我们把$a[1]$的值修改为了$x$，那么剩下的点都为被改为$a[i]\oplus x$。

    显然剩下的点也需要满足$l[i]\le a[i]\oplus x\le r[i]$。

    假如不等式两边可以同时异或的话，那么上式就可以转化为$l[i] \oplus a[i] \le x \le r[i] \oplus a[i]$

    那么问题就转换为，对于$n$个上式的不等式，求出$x$的可行解。
    
2.  但是对于一个不等式，是不能够直接异或的，因为对于一个区间，异或上一个数后，得到的新的区间，**不一定**是连续的。注意用词，是**不一定**连续，假如我们可以**把区间分解为几个在异或一个数之后，仍然为连续的区间**的话，那么问题就会转变为**对于多个形如上式的不等式，求出$x$的可行解**。所以我们来寻找什么样的区间，可以满足这个条件。

    > 二进制下，只要满足000，001，010，011 .....111之间的每个数都存在，那么这个区间异或上一个数之后，还是一个连续的区间。(大家可以试一试)
    >
    > 进一步来说，假如某个区间的所有数，在二进制下为n位，前面k位数都一样，且剩下的位数，刚好满足从0到2^(n - k+1) -1的每个数都有，那么这个区间异或上一个数之后也还为连续的，因为异或之后的每个数，前面k位依然相同，后面的数异或后也是一个连续的区间，那么连起来依然是一个连续的区间。
    

3.那么我们就可以统计以下每个区间异或之后的新区间，统计有哪些地方被覆盖的次数超过$n$次（即满足 $n$个不等式）。我们可以用类似于**权值线段树**的形式，即**每个点代表当前这个值被覆盖的次数**。为什么要用线段树呢？因为如果直接对整个区间进行统计的话，就需要从1统计到2^31-1，显然是无法通过空间限制的，但是用线段树统计的时候，我们可以用**打标记**，即类似于区间修改的方式来提前终止递归，从而降低了空间复杂度与时间复杂度。(一个范围为W的区间最多被分为$log(W)$个部分)

4.那么代码主要就分为以下几步

* 先默认$a[1] = 0$求出每个点的初始权值
* 把每个区间分为异或后依然连续的区间（权值线段树操作）
* 计算异或后的区间并作统计（差分）
* 统计合法的结果数量（对差分数组排序，求前缀和）

### 代码

```c++
#include <cstdio>
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

const int maxN = 1e5 + 5;
int n, l[maxN], r[maxN], head[maxN], cnt, W[maxN], ans, sum;

struct SegmentTree {
    int val, laz;
    bool operator < (const SegmentTree &t)const {
        if(val != t.val)
            return val < t.val;
        return laz < t.laz;
    }
};

struct Edge {
    int from, to, w;
}e[maxN << 1];

inline void add(int u, int v, int w)
{
    e[++cnt].from = head[u];
    e[cnt].to = v;
    e[cnt].w = w;
    head[u] = cnt;
}

void dfs(int u,int fa,int val) { //第一步
    W[u]  =val;
    for(int i = head[u]; i; i = e[i].from) {
        int v =e [i].to,p =e [i].w;
        if(v != fa)
            dfs(v, u, val ^ p);
    }
}

vector<SegmentTree> V;
void operation(int l, int r, int val) //求出每个区间异或后的区间并作差分
{
    SegmentTree a1, a2;
    int len = r - l + 1;
    a1.val = (l ^ (val & (~(len - 1))));
    a2.val = a1.val + len;
    a1.laz = 1; a2.laz = -1;
    V.push_back(a1); V.push_back(a2);
}

void Search(int L,int R,int l,int r,int val) { //第二步:分区间
    if(L <= l && R >= r) {
        operation(l, r, val);
        return ;
    }
    int mid = (l + r) >> 1;
    if(L <= mid)
        Search(L, R, l, mid, val);
    if(R > mid)
        Search(L, R, mid + 1, r, val);
}

int main()
{
    scanf("%d", &n);
    for(int i = 1; i <= n; ++i)
        scanf("%d%d", &l[i], &r[i]);
    for(int i = 1; i < n; ++i) {
        int x, y, z;
        scanf("%d%d%d", &x, &y, &z);
        add(x, y, z); add(y, x, z);
    }
    dfs(1, 0, 0);
    for(int i = 1; i <= n; ++i)
        Search(l[i], r[i], 0, (1 << 30) - 1, W[i]);
    sort(V.begin(), V.end());//对差分数组进行差分
    int len = V.size(), sum = 0, ans = 0;
    for(int i = 0; i < len; ++i) { //求前缀和并做统计
        sum += V[i].laz;
        if(sum == n)
            ans += V[i + 1].val - V[i].val;
    }
    printf("%d\n", ans);
    return 0;
}
```

#  F题
[比赛地址](https://ac.nowcoder.com/acm/contest/11255) |
[原题地址](https://ac.nowcoder.com/acm/contest/11255/F)

## 题目描述
Alice和Bob在玩游戏，游戏的规则如下：
* 游戏的对象是一个无向图。
* Alice和Bob轮流行动，Alice先行动，无法行动一方判负。
* 行动方式有两种：
    1. 删掉选定的一条边。
    2. 删掉一个无环的连通块。

求谁能获得游戏的胜利。
### 输入数据
第一行两个整数n,m为无向图的点数和边数。
之后m行每行两个整数u,v描述连接两点的边。
数据保证没有自环和重边。

数据范围: 1≤n≤100 , 0≤m≤min(200,n(n−1)/2)
### 输出数据
一个字符串为胜利者的名字
## 分析
这道题是一道明显的博弈问题，而且作为签到题，理应不会太复杂。
所以我们可以简单的分析一下：

* 胜利的条件：对方无法行动，即轮到自己时只剩一个连通块获胜。
* 行动带来的影响：
    * 删边：一个连通块变成两个，或一个环被拆开。
    * 删连通块：使场上无环连通块数量减一。

进一步分析发现，即使删除连通块上的一条边，对结果并没有影响。删边操作等效于让环的数目减一。

所以可以得出结论：连通块的数量加上环的数量为奇数时，先手获胜，否则后手获胜。

~~所以我们dfs一下就能得出结论~~

这是我们当时的做法，结果后来发现这题实际上更简单：
* 删边：边数减一
* 删连通块：点数减k，边数减(k-1)

于是我们把点数和边数加起来，发现每次操作都会导致这个数奇偶性发生变化。

可以据此导出答案：点数加边数为奇数，先手获胜，否则后手获胜。

~~得知这个方法后我们一度...~~
## 代码
```cpp
    #include<iostream>
    using namespace std;
    int main()
    {
        int n,m,a;
        cin>>n>>m;
        a=n+m;
        if(a%2)
            cout<<"Alice"<<endl;
        else
            cout<<"Bob"<<endl;
        return 0;
    } 
```
###### 作者：不爆零就算胜利
###### 牛客ID：454283533