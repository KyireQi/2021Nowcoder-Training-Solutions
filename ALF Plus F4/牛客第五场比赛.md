##  牛客比赛第5场



## K题

### 题目大意

给定一个$n$个数的序列$a_i$。有$q$次询问，每次询问是一个非负整数$k$，求出有多少对$(l, r)$，满足$max(a[i]) - min(a[j]) > k$,其中$l\le i, j \le r$。

### 思路

不难发现满足要求的序列有单调性，即**如果当前区间满足最大值减去最小值大于k，那么包含这个区间的更大的区间，也一定满足**。

而这一类问题，通常可以采用尺取法。即：

* 我们先固定起点$l$，然后让$r$从$l$开始一个一个往后走，并记录最大值与最小值。
* 一旦当前序列满足了条件，那么选取$r$之后的点作为结尾，也一定会满足，所以直接让答案$ans += n - r + 1$，然后让$l$后移动一位
* 因为$r$在恰好满足条件的时候就不在移动了，所以$l$在往后移动一位的时候，满足条件的结尾一定在$r$点或之后，所以$r$的起点还是当前位置，然后继续按照第一步继续，直到统计完成。
* 因为我们需要记录区间的最大值和最小值，所以我们可以用两个单调队列来统计，即统计最大值的时候，如果新加入的数$X$比当前的数$Y$要大，那么就让$Y$出队，因为**X比Y大还比它靠后，意味着在取最大值的时候，只要有X在，就永远不会取到Y，而X又在Y之后，也就是说它出队也晚于Y，所以Y就没有存在的必要了~~（惨 Y 惨）~~**。

### 代码

```cpp
#include <cstdio>
#include <iostream>
#include <deque>
#include <cstring>
#include <algorithm>
using namespace std;

const int maxN = 1e5 + 7;
typedef long long ll;

int m, n, a[maxN];

ll calc(ll k)
{
    deque<int> maxPos, minPos;
    int l = 1,r = 0;
    ll ans = 0;
    while(l <= n && r <= n) {
        while((!maxPos.empty()) && maxPos.front() < l)
            maxPos.pop_front();
        while((!minPos.empty()) && minPos.front() < l)
            minPos.pop_front();
        if((!maxPos.empty()) && a[maxPos.front()] - a[minPos.front()] > k) {
            ans += n - r + 1;
            ++l;
            continue;
        }
        else {
            ++r;
            while(!maxPos.empty() && a[maxPos.back()] <= a[r])
                maxPos.pop_back();
            maxPos.push_back(r);
            while(!minPos.empty() && a[minPos.back()] >= a[r])
                minPos.pop_back();
            minPos.push_back(r);
        }
    }
    return ans;
}

int main()
{
    scanf("%d%d", &n, &m);
    for(int i = 1; i <= n; ++i)
        scanf("%d", &a[i]);
    for(int i = 1; i <= m; ++i) {
        int k;
        scanf("%d", &k);
        printf("%lld\n", calc(k));
    }
    return 0;
}
```



## H题

签到题，构造一个$n\times m$的$01$矩阵，要求横着，竖着，斜着不能有连续的三个1或者0。

只需0011

​		1100

这么构造即可

```cpp
#include<iostream>
using namespace std;
int main()
{
    int ans[]={0,0,1,1};
    int n,m;
    cin>>n>>m;
    for(int i=0;i<n;i++)
    {
        for(int j=0;j<m;j++)
            if(i%2==0)
                cout<<ans[j%4];
            else
                cout<<ans[(j+2)%4];
        cout<<endl;
    }
    return 0;
}
```



## D题目

### 题目大意

给定两个字符串A，B，求出满足以下条件的子序列a,b（可以不连续）的数量 ，并对$10^9+7$取模：

* a，b分别来自A，B，且长度$length$相同
* $\exist i \in [1,length]$,使得$a_i < b_i$
* $\forall j \in [1, i)$,满足$a_j = b_j$。
* 对于$k \in [i + 1, length]$，$a_k,b_k$没有任何限制。

### 思路

* 假如我们已经找到了$A_{a1}...A{a_n}$，和$B_{b_1}...B_{b_n}$相同，那么我们只需要在$A$数组$A_{a_n}$后面中找到一个字母$A_{a_{n+1}}$ ，在$B$数组$B_{b_n}$后面中找到一个字母$B_{b_{n+1}}$，满足$A_{a_{n+1}} < B_{b_{n+1}}$即可，那么剩下的字母就可以随便选了。
* 假设$A$数组还剩$n$个数可选，$B$数组还剩$m$个可选，那么利用组合数学，就可知道共有$\sum_{i=0}^{min(n,m)} C_n^i + C_m^i$种选法。而此式子等于$C_{n+m}^n$。（具体证明可以参照百度）。~~（蒟蒻不太会）~~
* 那么剩下的就是统计$A,B$数组有多少个字串是相同的了。我们假设$dp[i][j]$表示在$A$数组前$i$位，$B$数组的前$j$位中共有几个相同的字串，递推时(有点类似与最长公共子序列)：
  * 如果$A[i] \not= B[j]$，那么它显然是由$A$数组前$i-1$个字母和$B$数组前$j$个组成，或者是$A$数组前$i$个字母和$B$数组前$j-1$个组成的。但是如果我们直接加上$dp[i-1][j],dp[i][j-1]$的话，会出现多加的情况，那就是$A$数组前$i-1$个字母和$B$数组前$j-1$个组成的,所以我们要再减去$dp[i-1][j-1]$，综上：$dp[i][j]=dp[i-1][j]+dp[i][j-1]-dp[i-1][j-1]$。
  * 如果$A[i] = B[j]$，那么它显然也可以由$dp[i][j]=dp[i-1][j]+dp[i][j-1]-dp[i-1][j-1]$得到一部分结果，其他的部分，就是由$A$数组前$i-1$个字母和$B$数组前$j-1$个，再加上$A[i],B[j]$两个字母，即$dp[i-1][j-1]$，其次$A[i],B[j]$两个字母也可以单独作为结果计算，综上：$dp[i][j]=dp[i-1][j]+dp[i][j-1]+1$。
* 因为结果是要求对结果进行取模的，而且我们的计算中是存在**组合数**的，所以不能每次都用费马小定理，所以我们需要预处理出阶乘数组和其对应的乘法逆元数组。

### 代码

```c++
#include <cstdio>
#include <iostream>
#include <cstring>
using namespace std;

typedef  long long ll;
const int maxN = 2000005, mod = 1000000007;

ll inv[maxN + 1], f[maxN + 1];

string s1, s2;
long long dp[5005][5005];
int len1, len2;

void exgcd(int a, int b, ll &x, ll &y) //拓展欧几里得
{
    if(b == 0) {
        x = 1; y = 0;
        return ;
    }
    exgcd(b, a % b, y, x);
    y -= a / b * x;
}

void init()
{
    f[0] = 1;
    for(int i = 1; i <= maxN; ++i)
        f[i] = f[i - 1] * i % mod; //阶乘数组
    ll x, y;
    exgcd(f[maxN], mod, x, y);
    inv[maxN] = (x % mod + mod) % mod;
    for(int i = maxN - 1; i; --i) {
        inv[i] = inv[i + 1] * (i + 1) % mod; //逆元数组
    }
}

ll C(ll n, ll m)
{
    if(n == m || m == 0)
        return 1;
    if(m > n)
        return 0;
    return (f[n] * inv[m] % mod * inv[n - m] % mod) % mod;
}

int main()
{
    cin >> s1; cin >> s2;
    len1 = s1.length(); len2 = s2.length();
    s1 = " " + s1; s2 = " " + s2;
    init();
    for(int i = 1; i <= len1; ++i) {
        for(int j = 1; j <= len2; ++j) {
            if(s1[i] == s2[j])
                dp[i][j] = (dp[i - 1][j] + dp[i][j - 1] + 1) % mod;
            else
                dp[i][j] = ((dp[i - 1][j] + dp[i][j - 1]) % mod + mod - dp[i - 1][j - 1]) % mod;
        }
    }
    long long ans = 0;
    for(int i = 1; i <= len1; ++i) {
        for(int j = 1; j <= len2; ++j) {
            if(s1[i] < s2[j]) {
                long long n = len1 - i, m = len2 - j;
                ans = (ans + (dp[i - 1][j - 1] + 1ll) * C(1LL * n + m, 1LL * min(n, m)) % mod) % mod;
            }
        }
    }
    cout << ans << endl;
    return 0;
}
```



## B题

### 题目大意

有$n$个盒子，每个盒子里装有一个球，它可能是黑色或者白色的概率均为$1/2$。现在你可以花费$C$的价值来获得**剩下的所有盒子中剩余的黑色球数量和白色球数量**。还可以花费$w[i]$的价值去打开一个盒子。

问： 你知道所有盒子中球的颜色的期望花费是多少。
[题目链接](https://ac.nowcoder.com/acm/contest/11256/B)

<!--more-->

### 思路

首先我们需要知道我们什么情况下可以知道每个盒子中球的颜色，即**剩下没开的盒子数量刚好等于剩下的盒子中某个颜色球的数量**

（或者我们可以不询问，直接打开所有的盒子）

比如：还剩下三个盒子，然后我们知道剩下的盒子中黑球的数量有3个。

假如我们还无法确定，那么我们打开盒子的顺序一定是从**最便宜**的开始打开，且如果我们要询问，那一定是要在刚开始时询问（什么时候询问花费都一样，在最开始询问有最大的可能知道剩下的盒子中球的颜色）。

我们定义$sum[i]$为$w[i]$从小到大排序后的前缀和，$p[i]$表示**至少打开第$i$个盒子才知道所有盒子球的颜色的概率。**

那么根据数学期望的定义，询问之后再一个一个打开的数学期望就是

$$ans = \sum_{i=0}^{n}sum[i]*p[i]$$

接下来我们来分析$p[i]$怎么算。注意定义**至少打开第$i$个盒子才知道所有盒子球的颜色的概率。**也就是说，我们打开第$i-1$个盒子的时候，仍然不知道，打开了第$i$个盒子的时候，刚好就知道了。说明：

* 从第$i+1$到$n$个盒子的颜色都相同
* **第$i$个盒子与剩下没打开的盒子颜色不同**

第二点有些不好想，因为假如第$i$个盒子颜色与剩下的相同，那么我们在打开第$i-1$个盒子的时候就已经知道剩下盒子的颜色了。

剩下的盒子有$n-i$个，$n-i$个盒子颜色颜色相同概率为$1/2^{n-i-1}$，而又要与第$i$个盒子的球颜色不同，所以要再乘以$1/2$。

综上$p[i]=1/2^{n-i}$。

还有，假如我们这么得到的期望还不如直接不询问，全部打开的话，那我们完全可以直接全部打开。

所以

$$ans=max(\sum_{i=0}^{n}sum[i]*(1/2^{n-i}), sum[n])$$



### 代码

```c++
#include <iostream>
#include <cstring>
#include <cstdio>
#include <algorithm>
#include <cmath>
using namespace std;

const int maxN = 1e5 + 7;

int n;

double a[maxN], preSum, ans, C;

bool cmp(double x, double y)
{
    return x < y;
}

int main()
{
    cin >> n >> C;
    ans = C;
    for(int i = 1; i <= n; ++i)
        cin >> a[i];
    sort(a + 1, a + 1 + n,cmp);
    for(int i = 1; i <= n; ++i) {
        ans += preSum * pow(0.5, n - i + 1);
        preSum += i[a];
    }
    ans = min(ans, preSum);
    printf("%.7f", ans);
    return 0;
}
```